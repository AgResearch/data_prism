#################################
# custom version of a standard script - adds specific 
# labels 
#################################

library(Heatplus)
library(RColorBrewer)
library(gplots)


input_file="kmer_summary.txt"                                                         

colname_pattern=NULL   

heatmap_image_file="kmer_entropy.jpg"                                             
number_of_heatmap_row_labels=100  

# next is the number of labels that will appear in the 
# heatmap, and in the dimensional scaling plot                                                
number_of_column_labels=200 # usually 50  

zipfian_plots_per_row=4                                                           
zipfian_plot_image_file="kmer_zipfian.jpg"                                        

# next is a list of column name patterns which is used to select the 
# columns displayed in the "comparison plot" which includes
# multiple samples. In addition , all columns in this list will 
# be labelled in the dimensional scaling plot. 
# if set to NULL, all samples will be included in the "comparison plot"
# (and no additional samples will be labelled in the dimensional
# scaling plot)
# examples: 
#zipfian_plot_comparisons=c("1128_S28")
#zipfian_plot_comparisons=c("19_8Kb_1","reads19_1.*")                     
#zipfian_plot_comparisons=c("X3.*", "X4.*", "X5.*")                                
#zipfian_plot_comparisons=c("GA194_B53_C9CHFANXX_7_2554_X4.cnt","GA194_B40_C9CHFANXX_7_2554_X4.cnt")                                
#zipfian_plot_comparisons=c("SQ2530","SQ2531","SQ2533","SQ2534","SQ2535","SQ2536","SQ2537","SQ2538","SQ2539","SQ2540","SQ2541","SQ2515","SQ2516","SQ2517","SQ2518")

zipfian_plot_comparisons=NULL



comparison_plot_image_file="kmer_zipfian_comparisons.jpg"                         
distances_plot_image_file="zipfian_distances.jpg"                                 
################## End of options. Remaining just code ################################


get_command_args <- function() {
   args=(commandArgs(TRUE))
   if(length(args)!=1 ){
      #quit with error message if wrong number of args supplied
      print('Usage example : Rscript --vanilla  kmer_plots_gbs.r datafolder=/dataset/hiseq/scratch/postprocessing/160623_D00390_0257_AC9B0MANXX.gbs/SQ2559.processed_sample/uneak/kmer_analysis')
      print('args received were : ')
      for (e in args) {
         print(e)
      }
      q()
   }else{
      print("Using...")
      # seperate and parse command-line args
      for (e in args) {
         print(e)
         ta <- strsplit(e,"=",fixed=TRUE)
         switch(ta[[1]][1],
            "datafolder" = datafolder <- ta[[1]][2]
         )
      }
   }
   return(datafolder)
}


custom_parser <- function(field_name) {
   # this will parse a fieldname using a regular expression 
   # "colname_parser" defined in the workspace. (It is not 
   # a closure as the function does not need to re-defined 
   # after changing the value of colname_parser)
   result=field_name
   match<-regexpr(colname_pattern,field_name)
   if (match != -1) {
      result = substr(field_name,match,match+attr(match,"match.length")-1)
   }
   return(result)
}

get_data<-function(data_folder, input_file_name, colname_pattern) {
   #
   #this function reads a structured text file (generated by kmer_entropy.py) which contains 
   #three sections. The structured text file looks like this : 
   #-------------------------------------------------------
   #*** ranks *** :
   #kmer_pattern	14_8Kb_1.fastq.kmerdist	...
   #AAAAAA	35	...
   #AAAAAC	109	...  
   #.
   #.
   #TTTTTT	750	...
   #*** entropies *** :
   #kmer_pattern	14_8Kb_1.fastq.kmerdist	...
   #AAAAAA	9.15653805702	...
   #AAAAAC	10.1764807643	...
   #.
   #.
   #*** distances *** :
   #	14_8Kb_1.fastq.kmerdist	... 
   #14_8Kb_1.fastq.kmerdist	0	...
   #.
   #.
   # -----------------------------------------------------
   #The file is parsed and each section is read into a data frame. The three 
   #data frames are bundled into a single list which is returned as the 
   #value of the function. 
   #
   #Example usage: 
   #
   #mydata <- get_data(data_folder, input_file)
   #
   #


   # read the data into a big character vector
   setwd(data_folder)
   Lines <- readLines(input_file_name)

   # parse the data - see example format above. Parse out 
   # a table of ranks, entropies and distances between 
   # samples using a "zipfian" metric

   selected_lines = as.vector(character())
   for(line in Lines) {
      if(substr(line, 0, 13) == "*** ranks ***") {
         selected_lines = as.vector(character())
         next
      }
      if(substr(line, 0, 17) == "*** entropies ***") {
         rank_lines = selected_lines
         selected_lines = as.vector(character())
         next
      }
      if(substr(line, 0, 17) == "*** distances ***") {
         entropy_lines = selected_lines
         selected_lines = as.vector(character())
         next
      }
      selected_lines=c(selected_lines, line)
      distance_lines=selected_lines
   }
   results = list()
   results$rank_data = read.table(textConnection(rank_lines), header=TRUE, row.names=1, sep="\t")
   results$entropy_data = read.table(textConnection(entropy_lines), header=TRUE, row.names=1, sep="\t")
   distance_data<-read.table(textConnection(distance_lines), header=TRUE, row.names=1, sep="\t")

   # auto-tidy the variable names slightly (remove .kmerdist suffix , and .fastq and .gz ) 
   for(pattern in c(".kmerdist", ".fastq", ".gz")) {
      colnames(results$rank_data) <- sub(pattern,"",colnames(results$rank_data))
      colnames(results$entropy_data) <- sub(pattern,"",colnames(results$entropy_data))
      colnames(distance_data) <- sub(pattern,"",colnames(distance_data))
      rownames(distance_data) <- sub(pattern,"",rownames(distance_data))
   }

   # custom-tidy the variable names if requested
   if( ! is.null(colname_pattern)) {   
      colnames(results$rank_data) <- sapply( colnames(results$rank_data), custom_parser)
      colnames(results$entropy_data) <- sapply( colnames(results$entropy_data), custom_parser)
      colnames(distance_data) <- sapply( colnames(distance_data), custom_parser)
      rownames(distance_data) <- sapply( rownames(distance_data), custom_parser)
   }

   # order each data frame by column name so things are easier to find in plots
   results$rank_data <- results$rank_data[,order(colnames(results$rank_data))]
   results$entropy_data <- results$entropy_data[,order(colnames(results$entropy_data))]

   # distances are distances
   results$distance_data <- as.dist(distance_data)

   # supply log-rank 
   results$log_rank_data = log(results$rank_data,2)

  
   return(results)
}

draw_entropy_heatmap <- function(datamatrix, output_folder, heatmap_image_file, number_of_heatmap_row_labels, number_of_column_labels) {
   # draws a heatmap based on the 
   # self-information of the kmers in the data
   # (i.e. rare kmer = large self information, abundant kmer = low self information)
   setwd(output_folder)
   row_label_interval=max(1, floor(nrow(datamatrix)/number_of_heatmap_row_labels))  # 1=label every location 2=label every 2nd location  etc 
   col_label_interval=max(1, floor(ncol(datamatrix)/number_of_column_labels))  # 1=label every location 2=label every 2nd location  etc 

   #cm<-brewer.pal(9,"BuPu") # sequential
   cm <-c("#F7FCFD", "#E0ECF4", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8C6BB1", "#88419D", "#810F7C", "#4D004B")
   cm <- rev(cm)

   # set up a vector which will index the labels that are to be blanked out so that 
   # only every nth row is labelled, 
   # the rest empty strings, n=row_label_interval.
   rowLabels <- rownames(as.matrix(datamatrix))
   rowBlankSelector <- sequence(length(rowLabels))
   rowBlankSelector <- subset(rowBlankSelector, rowBlankSelector %% row_label_interval != 0) 
                       # e.g. will get (2,3, 5,6, 8,9, ..)
                       # so we will only label rows 1,4,7,10,13 etc)

   # set up a vector which will index the labels that are to be blanked out so that 
   # only every nth col is labelled, 
   # the rest empty strings, n=col_label_interval.
   colLabels <- colnames(as.matrix(datamatrix))
   colBlankSelector <- sequence(length(colLabels))
   colBlankSelector <- subset(colBlankSelector, colBlankSelector %% col_label_interval != 0) 
                       # e.g. will get (2,3, 5,6, 8,9, ..)
                       # so we will only label rows 1,4,7,10,13 etc)

   jpeg(filename = heatmap_image_file, width=1300, height=1200) # with dendrograms

   # run the heatmap, just to obtain the clustering index - not the final plot
   hm_internal<-heatmap.2(as.matrix(datamatrix),  scale = "none", dendrogram = "col",
    Colv = TRUE,  
     trace = "none", breaks = 0 + 15/9*seq(0,9),
     col = cm , key=FALSE, density.info="none", 
     keysize=1.0, margin=c(11,20), cexRow=1.5, cexCol=1.5, 
     lmat=rbind(  c(4,3,0 ), c(2, 1, 0) ), lwid=c(.7, 1.7, .6 ), lhei=c(.5, 3) , labRow = rowLabels)

   dev.off()

   # edit the re-ordered vector of row labels, obtained from the heatmap object, so that only 
   # every nth label on the final plot has a non-empty string
   # this is for the internal distance matrix
   indexSelector <- hm_internal$rowInd[length(hm_internal$rowInd):1]    
   indexSelector <- indexSelector[rowBlankSelector]
   rowLabels[indexSelector] = rep('',length(indexSelector))


   # edit the re-ordered vector of col labels, obtained from the heatmap object, so that only 
   # every nth label on the final plot has a non-empty string
   # this is for the internal distance matrix
   indexSelector <- hm_internal$colInd[length(hm_internal$colInd):1]    
   indexSelector <- indexSelector[colBlankSelector]
   colLabels[indexSelector] = rep('',length(indexSelector))


   # now do the final plot
   jpeg(filename = heatmap_image_file, width=1300, height=1500) # with dendrograms
   hm<-heatmap.2(as.matrix(datamatrix),  scale = "none", dendrogram = "col",
       Colv = TRUE,  
       trace = "none", breaks = min(datamatrix) + (max(datamatrix)-min(datamatrix))/9*seq(0,9), 
       col = cm , key=FALSE, density.info="none", 
       keysize=1.0, margin=c(40,60), cexRow=1.3, cexCol=1.3, 
       lmat=rbind(  c(4,3,0 ), c(2, 1, 0) ), lwid=c(.2, .8, 0 ), lhei=c(.5, 3) , labRow = rowLabels, labCol=colLabels)
   dev.off()

   # the column labels on the plots are usually too crowded so supply a file with the 
   # column names ordered as per the plot
   write.table(colnames(as.matrix(datamatrix))[hm$colInd[1:length(hm$colInd)]] , file="samplenames_ordered.dat",row.names=TRUE,sep="\t")

}


draw_zipfian_plots <- function(datalist, output_folder, zipfian_plot_image_file, zipfian_plots_per_row) {
   # draws "zipfian" plots for each sample (one plot per sample)
   # these are plots of entropy ~ log( kmer self-information rank)  
   # (- i.e. very similar to "zipf law" plot of log(freq) ~ log (freq rank), but with different 
   # slope and intercept)
   plot_rows = ceiling(ncol(datalist$log_rank_data)/zipfian_plots_per_row)
   plot_width=1300
   plot_height = 300 * plot_rows
   jpeg(filename = zipfian_plot_image_file, plot_width, plot_height)
   par(mfrow=c(plot_rows, zipfian_plots_per_row))
   for (i in sequence(ncol(datalist$log_rank_data))) {
      plot(datalist$log_rank_data[,i], datalist$entropy_data[,i],pch='.',main=colnames(datalist$log_rank_data)[i])
   }
   dev.off()
}


draw_comparison_plot <- function(datalist, output_folder, comparison_plot_image_file, comparison_columns_patterns) {
   # all / select samples in a single "zipfian" plot
   coloured_samples =c("X241190_C9AB9ANXX_4_223_X4.cnt",
                       "X241191_C9AB9ANXX_4_223_X4.cnt",
                       "X241192_C9AB9ANXX_4_223_X4.cnt",                       
		       "X241193_C9AB9ANXX_4_223_X4.cnt",                       
                       "X241194_C9AB9ANXX_4_223_X4.cnt",
                       "X241195_C9AB9ANXX_4_223_X4.cnt",
                       "X241196_C9AB9ANXX_4_223_X4.cnt",
                       "X241197_C9AB9ANXX_4_223_X4.cnt")

   default_colour=par("col")
   colours=rep(default_colour, ncol(datalist$entropy_data))
   blue_plots=sequence(ncol(datalist$entropy_data))
   blue_plots <- subset(blue_plots,  colnames(datalist$entropy_data) %in% coloured_samples) 
   other_plots=sequence(ncol(datalist$entropy_data))
   other_plots <- subset(other_plots,  ! colnames(datalist$entropy_data) %in% coloured_samples) 
   colours[blue_plots] <- "blue"




   comparison_columns = as.vector(integer())
   if ( ! is.null(comparison_columns_patterns)) { 
      for (comparison_pattern in comparison_columns_patterns){
         comparison_columns = c(comparison_columns, grep(comparison_pattern,colnames(datalist$entropy_data), ignore.case = TRUE) )
      }
   }
   else {
      comparison_columns = sequence(ncol(datalist$entropy_data))
   }

   if (length(comparison_columns) == 0) {
      comparison_columns = sequence(ncol(datalist$entropy_data))
   }

   log_rank_subset=datalist$log_rank_data[,comparison_columns[1]]
   entropy_subset=datalist$entropy_data[,comparison_columns[1]]

   if (length(comparison_columns) > 1) {
      for(column_number in comparison_columns[2:length(comparison_columns)]) {
         entropy_subset=cbind(entropy_subset, datalist$entropy_data[,column_number])
         log_rank_subset = cbind(log_rank_subset, datalist$log_rank_data[,column_number])
      }
   }

   jpeg(filename = comparison_plot_image_file, 800,800)
   if (length(comparison_columns) < 30 ) {
      #plot(log_rank_subset, entropy_subset, pch='.', xlim=c(0,12), ylim=c(8,14))

      xmin <- par("usr")[1]
      xmax <- par("usr")[2]
      ymin <- par("usr")[3]
      ymax <- par("usr")[4]
      delta_y=(ymax-ymin)/40.0
      delta_x=(xmax-xmin)/5

      for(column_number in sequence(length(comparison_columns))) {
         text( xmin + delta_x , ymax - delta_y * (1+column_number), colnames(datalist$entropy_data)[comparison_columns[column_number]], adj = c( 0, 1 ))
      }
   }
   else {
      #plot(log_rank_subset, entropy_subset, pch='.', xlim=c(0,12), ylim=c(8,14))
      #par(mar=c(5.1,4.1,4.1,2.1))   # bottom, left , top , right - defaults
      par(mar=c(5.1,4.7,4.1,2.1))
      plot(log_rank_subset, entropy_subset, pch='.', xlim=c(0,12), ylim=c(8,14), xlab="log rank of 6-mer self information", 
          ylab="6-mer self information", cex.axis=2.0, cex.lab=2.0)


      #smoothScatter(
      #  log_rank_subset[,blue_plots], entropy_subset[,blue_plots],  
      #   pch='+', col="blue", xlim=c(0,12), ylim=c(8,14), xlab="log rank of 6-mer self information", ylab="6-mer self information") 

      #points(
      #   log_rank_subset[,other_plots], entropy_subset[,other_plots],  
      #   pch='.', xlim=c(0,12), ylim=c(8,14)) 


      title("Co-spectra of GBS tags from a lane of Ryegrass", cex.main=2.0)   # uncomment for the Ryegrass run 
      #title("Co-spectra of GBS tags from a lane of Deer and Cattle", cex.main=2.0)  # uncomment for the Cattle run 
      #title(main=paste( colnames(datalist$entropy_data)[1] , "....etc"))

      #text(1.6,10, "Deer Samples", pos=4, cex=2.0)
      #text(7, 10, "Cattle Samples", pos=4, cex=2.0)
      #text(6.5,11.5, "Controls", pos=4, cex=2.0)

   }
   dev.off()
}


draw_distances_plot <- function(datalist, output_folder, distances_plot_image_file, comparison_columns_patterns,  number_of_column_labels) {
   # the distance matrix (i.e. distances between each pair of zipfian plots)
   # is embedded in 2-D using mds and plotted. 
   # - look for groups and outliers
   # all / select samples in a single "zipfian" plot
   coloured_samples =c("X241190_C9AB9ANXX_4_223_X4.cnt",
                       "X241191_C9AB9ANXX_4_223_X4.cnt",
                       "X241192_C9AB9ANXX_4_223_X4.cnt",                       
		       "X241193_C9AB9ANXX_4_223_X4.cnt",                       
                       "X241194_C9AB9ANXX_4_223_X4.cnt",
                       "X241195_C9AB9ANXX_4_223_X4.cnt",
                       "X241196_C9AB9ANXX_4_223_X4.cnt",
                       "X241197_C9AB9ANXX_4_223_X4.cnt")

   default_colour=par("col")
   colours=rep(default_colour, ncol(datalist$entropy_data))
   blue_plots=sequence(ncol(datalist$entropy_data))
   blue_plots <- subset(blue_plots,  colnames(datalist$entropy_data) %in% coloured_samples) 
   colours[blue_plots] <- "blue"
   other_plots=sequence(ncol(datalist$entropy_data))
   other_plots <- subset(other_plots,  ! colnames(datalist$entropy_data) %in% coloured_samples) 
   


   fit <- cmdscale(datalist$distance_data,eig=TRUE, k=2)
   jpeg(filename = distances_plot_image_file, 800,800)
   smoothScatter(fit$points, cex=0.7,xlab="", ylab="", cex.axis=1.5, cex.lab=1.5)

   coloured_samples =c("241190_C9AB9ANXX_4_223_X4.cnt",
                       "241191_C9AB9ANXX_4_223_X4.cnt",
                       "241192_C9AB9ANXX_4_223_X4.cnt",
                       "241193_C9AB9ANXX_4_223_X4.cnt",
                       "241194_C9AB9ANXX_4_223_X4.cnt",
                       "241195_C9AB9ANXX_4_223_X4.cnt",
                       "241196_C9AB9ANXX_4_223_X4.cnt",
                       "241197_C9AB9ANXX_4_223_X4.cnt")
   #text(fit$points, labels = col_labels, pos = 4, cex=0.8)
   print(coloured_samples)
   print(rownames(fit$points))
   print(rownames(fit$points)  %in% coloured_samples)
   labelled  <- subset(sequence(nrow(fit$points)) ,  rownames(fit$points)  %in% coloured_samples)
   not_labelled  <- subset(sequence(nrow(fit$points)) ,  ! rownames(fit$points)  %in% coloured_samples)
   col_labels <- rownames(fit$points)
   col_labels[not_labelled] <- ''

   #text(fit$points, labels = col_labels, pos = 4, cex=0.8)   # label the cattle points
   text(0.3,-.05, "Deer Samples", pos=4, cex=2.0)
   text(1.5,-.35, "Cattle Samples", pos=4, cex=2.0)
   text(3.5,.3, "Controls", pos=4, cex=2.0)

   title("Performance of metric on zipfian plot space", cex.main=2.0)


   write.table(fit$points, "zipfian_distances_fit.txt", sep="\t")
   dev.off()
}

main <- function() {
   data_folder <- get_command_args()
   output_folder <- data_folder
   mydata <- get_data(data_folder, input_file, colname_pattern)
   #draw_entropy_heatmap(mydata$entropy_data, output_folder, heatmap_image_file, number_of_heatmap_row_labels, number_of_column_labels)
   #draw_zipfian_plots(mydata, output_folder, zipfian_plot_image_file, zipfian_plots_per_row) 
   draw_comparison_plot(mydata, output_folder, comparison_plot_image_file, zipfian_plot_comparisons)
   #draw_distances_plot(mydata, output_folder, distances_plot_image_file, zipfian_plot_comparisons, number_of_column_labels)
   return(mydata)
}


mydata<-main()






